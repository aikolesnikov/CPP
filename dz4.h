/*
1. Улучшенная программа для показа фигурок. В цикле выводит меню выбора прорисовываемой фигурки, запрашивает размер фигурки и символ прорисовки. В 
конце цикла запрашивает продолжать или нет.
Все прорисовки и меню в функциях. Меню с проверкой принимаемого значения – после меню программа должна получать правильные данные. 

1. Вычислить факториал числа n, которое вводит пользователь, с помощью while, а также  for. Отдельными функциями. 
n!  = 1*2* ….*(n-1)*n. 

Пример: Ввод:   n = 3; Вывод:  Factorial   3! = 6.

2. Функция принимает массив, находит в нем все четные, возвращает их количество, и записывает четные в другой массив (ф-ия принимает четыре параметра). 

3. Написать ф-ию, которая принимает массив символов в виде цифр (например ‘1’ , ‘5’, ‘3’ , ‘9’) и возвращает  целое число, которое состоит из этих цифр ( в виде  1539).

4. Написать функцию, которая принимает два массива одинакового размера и -  меняет их элементы так, чтобы первый массив стал инверсным вторым, а второй стал инверсным первым:

Дано:                                                                  Результат:
Массив1 – 1, 4, 5, 6, 2;                                Массив1 – 9, 7, 1, 6, 3;
Массив2 – 3, 6, 1, 7, 9;                                Массив2 – 2, 6, 5, 4, 1.

5. Задача Ремонт дороги:   Генерируется массив на сто элементов в диапазоне от 0 до 20. 
Каждый элемент – это количество выбоин на участке 100 метров дороги. До 10-и выбоин – 
хорошая дорога – рисуется символами *. Если плохой – символами  #, Если подряд 
встречаются 3 и более плохих участков, этот сектор отдается для ремонта бригаде со 
спецтехникой – рисуется символом $ .  Нарисовать гистограмму. (верхний цикл  For, 
внутри  while – в нем обязательная проверка на выход за пределы массива.) Учимся 
смотреть значения за пределами текущего. 
Например в массиве 5 10 11  6 12 13 14 16 3 

Вывод:
1 5 *****
2 10 ##########
3 11 ###########
4 6 ******
5 12 $$$$$$$$$$$$
6 12 $$$$$$$$$$$$$
7 12 $$$$$$$$$$$$$$
8 12 $$$$$$$$$$$$$$$$ 
9 6 ******

*/

// ----------------------------------------------------------------------------------- 

1. Написать функцию сортировки массива «выбором». (массивы должны быть одинаковыми memcpy(..)  и большими).

Сравнить эффективность методов (вычисление времени сортировки ): Пузырек, Оптимальный пузырек, метод Выбора. Сравнивать с помощью функции GetLocalTime (..) и SYSTEMTIME из библиотеки <windows.h>. 
Также попробовать инструменты clock(),  clock_t из библиотеки  <time.h>.

Шаги алгоритма:
1. находим номер минимального значения в текущем списке
2. производим обмен этого значения со значением первой неотсортированной 
3. теперь сортируем хвост списка, исключив из рассмотрения уже позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции) отсортированные элементы

2. Познакомиться с сортировкой методом Вставки. Сравнить эффективность всех методов.

3. Создать Ф-ию, которая принимает натуральное число. Она возвращает число, которое получается из исходного записью его цифр в обратном порядке (например, дано число 1569, нужно получить 9651).

4. Создать Ф-ию, которая принимает простое число. Находит следующее за ним простое число и его возвращает.
